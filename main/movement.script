local camera = require "orthographic.camera"

animation_idle = hash("idle")

function init(self)
	msg.post(".", "acquire_input_focus")
	self.current_animation = nil
	self.SPEED =40
	msg.post('.', 'start_camera')
	self.rotated_vector = vmath.vector3(0,0,0)
	self.animation = nil
	for _,v in ipairs({"move_up", "move_down", "move_left", "move_right", "up_idle", "down_idle", "left_idle", "right_idle"}) do
		self[v] = hash(v)
	end
	self.walking = false
end
function update(self, dt)
	self.dt = dt
	-- local animation = animation_idle
	-- if self.rotated_vector.y > 0  then
	-- 	animation = move_up
	-- elseif self.rotated_vector.y <0  then
	-- 	animation = move_down
	-- end
	-- if animation ~= self.current_animation then
	-- 	sprite.play_flipbook('#sprite', animation)
	-- 	self.current_animation = animation
	-- end
end

function on_message(self, message_id, message, sender)
	if message_id == hash('start_camera') then
		camera.follow(go.get_id('camera'), go.get_id(), {})
	end
end

function play_animation(self, direction, mode)
	local angle = math.deg(math.atan2(direction.y, direction.x))
	if angle >= 45 and angle < 135 then
		if mode == true then
			sprite.play_flipbook('#sprite', self.move_up)
		else
			sprite.play_flipbook('#sprite', self.up_idle)
		end
	elseif (angle >= 135 and angle <= 180) or (angle >= -180 and angle <-135) then
		if mode == true then
			sprite.play_flipbook('#sprite', self.move_left)
		else
			sprite.play_flipbook('#sprite', self.left_idle)
		end
	elseif angle >= -135 and angle < -45 then
		if mode == true then
			sprite.play_flipbook('#sprite', self.move_down)
		else
			sprite.play_flipbook('#sprite', self.down_idle)
		end
	elseif angle >= -45 and angle < 45 then
		if mode == true then
			sprite.play_flipbook('#sprite', self.move_right)
		else
			sprite.play_flipbook('#sprite', self.right_idle)
		end
	end
		
end

function on_input(self, action_id, action)
	if action_id == hash("Up") then
		local rotated_vector =  vmath.rotate(go.get_rotation(),vmath.vector3(0,10,0)*self.SPEED)
		local new_pos = go.get_position() + rotated_vector * self.dt
		
		go.set_position(new_pos)
		
		if action.pressed then
			self.walking = true
			play_animation(self, rotated_vector, true)
		elseif action.released then
			self.walking = false
			play_animation(self, rotated_vector, false)
		end
	elseif action_id == hash("Left") then
		local rotated_vector =  vmath.rotate(go.get_rotation(),vmath.vector3(-10,0,0)*self.SPEED)
		local new_pos = go.get_position() + rotated_vector * self.dt

		go.set_position(new_pos)

		if action.pressed then
			self.walking = true
			play_animation(self, rotated_vector, true)
		elseif action.released then
			self.walking = false
			play_animation(self, rotated_vector, false)
		end
	elseif action_id == hash("Right") then
		local rotated_vector =  vmath.rotate(go.get_rotation(),vmath.vector3(10,0,0)*self.SPEED)
		local new_pos = go.get_position() + rotated_vector * self.dt

		go.set_position(new_pos)

		if action.pressed then
			self.walking = true
			play_animation(self, rotated_vector, true)
		elseif action.released then
			self.walking = false
			play_animation(self, rotated_vector, false)
		end
	elseif action_id == hash("Down") then
		local rotated_vector =  vmath.rotate(go.get_rotation(),vmath.vector3(0,-10,0)*self.SPEED)
		local new_pos = go.get_position() + rotated_vector * self.dt
		
		go.set_position(new_pos)
		
		if action.pressed then
			self.walking = true
			play_animation(self, rotated_vector, true)
		elseif action.released then
			self.walking = false
			play_animation(self, rotated_vector, false)
		end
	end
end