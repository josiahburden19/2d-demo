local camera = require "orthographic.camera"

animation_idle = hash("idle")

function init(self)
	msg.post(".", "acquire_input_focus")
	self.current_animation = nil
	self.SPEED =40
	msg.post('.', 'start_camera')
	self.rotated_vector = vmath.vector3(0,0,0)
	self.animation = nil
	for _,v in ipairs({"move_up", "move_down", "move_left", "move_right", "up_idle", "down_idle", "left_idle", "right_idle"}) do
		self[v] = hash(v)
	end
	self.walking = false
end
function update(self, dt)
	self.dt = dt
-- 	print(camera.screen_to_world(go.get_id('camera'), vmath.vector3(0, 0, 0)), camera.screen_to_world(go.get_id('camera'), vmath.vector3(960, 640, 0)))
end

function on_message(self, message_id, message, sender)
	if message_id == hash('start_camera') then
		camera.follow(go.get_id('camera'), go.get_id(), {})
	end
end

function play_animation(self, direction, mode)
	local angle = math.deg(math.atan2(direction.y, direction.x))
	if angle >= 45 and angle < 135 then
		if mode == true then
			sprite.play_flipbook('#sprite', self.move_up)
		else
			sprite.play_flipbook('#sprite', self.up_idle)
		end
	elseif (angle >= 135 and angle <= 180) or (angle >= -180 and angle <-135) then
		if mode == true then
			sprite.play_flipbook('#sprite', self.move_left)
		else
			sprite.play_flipbook('#sprite', self.left_idle)
		end
	elseif angle >= -135 and angle < -45 then
		if mode == true then
			sprite.play_flipbook('#sprite', self.move_down)
		else
			sprite.play_flipbook('#sprite', self.down_idle)
		end
	elseif angle >= -45 and angle < 45 then
		if mode == true then
			sprite.play_flipbook('#sprite', self.move_right)
		else
			sprite.play_flipbook('#sprite', self.right_idle)
		end
	end
end

function on_input(self, action_id, action)
	if action_id == hash("Up") and (self.walking == false or self.walking == 'up') then
		local rotated_vector =  vmath.rotate(go.get_rotation(),vmath.vector3(0,10,0)*self.SPEED)
		local new_pos = go.get_position() + rotated_vector * self.dt
		
		go.set_position(new_pos)
		
		if self.walking == false then
			self.walking = 'up'
			sprite.play_flipbook('#sprite', self.move_up)
		elseif action.released and self.walking == 'up' then
			self.walking = false
			sprite.play_flipbook('#sprite', self.up_idle)
		end
	elseif action_id == hash("Left") and (self.walking == false or self.walking == 'left') then
		local rotated_vector =  vmath.rotate(go.get_rotation(),vmath.vector3(-10,0,0)*self.SPEED)
		local new_pos = go.get_position() + rotated_vector * self.dt

		go.set_position(new_pos)

		if self.walking == false then
			self.walking = 'left'
			sprite.play_flipbook('#sprite', self.move_left)
		elseif action.released and self.walking == 'left' then
			self.walking = false
			sprite.play_flipbook('#sprite', self.left_idle)
		end
	elseif action_id == hash("Right") and (self.walking == false or self.walking == 'right') then
		local rotated_vector =  vmath.rotate(go.get_rotation(),vmath.vector3(10,0,0)*self.SPEED)
		local new_pos = go.get_position() + rotated_vector * self.dt

		go.set_position(new_pos)
		
		if self.walking == false then
			self.walking = 'right'
			sprite.play_flipbook('#sprite', self.move_right)
		elseif action.released and self.walking == 'right' then
			self.walking = false
			sprite.play_flipbook('#sprite', self.right_idle)
		end
	elseif action_id == hash("Down") and (self.walking == false or self.walking == 'down') then
		local rotated_vector =  vmath.rotate(go.get_rotation(),vmath.vector3(0,-10,0)*self.SPEED)
		local new_pos = go.get_position() + rotated_vector * self.dt

		go.set_position(new_pos)
		
		if self.walking == false then
			self.walking = 'down'
			sprite.play_flipbook('#sprite', self.move_down)
		elseif action.released and self.walking == 'down' then
			self.walking = false
			sprite.play_flipbook('#sprite', self.down_idle)
		end
	end
end